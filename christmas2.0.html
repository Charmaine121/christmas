<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Merry Christmas from Char</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        #text {
            position: absolute; 
            top: 10%; /* MOVED TO TOP */
            width: 100%; text-align: center;
            color: #ffca28; font-family: 'Georgia', serif; font-style: italic; font-size: 2.5rem;
            text-shadow: 0 0 15px #ff6f00, 0 0 30px #ff0000; opacity: 0; transition: opacity 2s;
            pointer-events: none;
            z-index: 10; /* Ensure it's on top of snow */
        }
    </style>
</head>
<body>
    <div id="text">Merry Christmas from Char</div>

    <script type="module">
        import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

        // --- CONFIGURATION ---
        const PARTICLE_COUNT = 18000; 
        const RESERVE_COUNT = 6000;   // Finale particles
        const HEART_COUNT = 2000;     
        const SNOW_COUNT = 3000;      // Snow particles
        
        const CAM_DIST = 70;

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 20, CAM_DIST);
        camera.lookAt(0, 15, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const g = ctx.createRadialGradient(16,16,0, 16,16,16);
            g.addColorStop(0, 'rgba(255,255,255,1)');
            g.addColorStop(0.2, 'rgba(255,255,255,0.8)'); 
            g.addColorStop(1, 'transparent');
            ctx.fillStyle = g;
            ctx.fillRect(0,0,32,32);
            return new THREE.CanvasTexture(canvas);
        }

        // --- MAIN SYSTEM (Fireworks, Tree, Heart) ---
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(PARTICLE_COUNT * 3);
        const sizes = new Float32Array(PARTICLE_COUNT);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        const data = [];
        const treeTargets = [];
        const galaxyTargets = [];
        const heartTargets = [];

        // PALETTES
        const goldPalette = [ new THREE.Color('#FFD700'), new THREE.Color('#FFA500'), new THREE.Color('#FF8C00') ];
        const whitePalette = [ new THREE.Color('#FFFFFF'), new THREE.Color('#F0F8FF') ];
        const heartPalette = [ new THREE.Color('#FF0000'), new THREE.Color('#DC143C') ]; 

        // HEART SHAPE
        function getHeartOutline(angle) {
            const x = 16 * Math.pow(Math.sin(angle), 3);
            const y = 13 * Math.cos(angle) - 5 * Math.cos(2 * angle) - 2 * Math.cos(3 * angle) - Math.cos(4 * angle);
            return { x: x, y: y };
        }

        const RING_COUNT = 30; 
        const STRUCTURE_COUNT = PARTICLE_COUNT - RESERVE_COUNT; 

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            let dest = 'RESERVE'; 
            let c;

            // Permanent Structures
            if (i < STRUCTURE_COUNT) {
                let isHeart = i >= (STRUCTURE_COUNT - HEART_COUNT);
                let isTree = !isHeart && (Math.random() > 0.4);
                
                dest = isHeart ? 'HEART' : (isTree ? 'TREE' : 'RING');
                
                if (isHeart) c = heartPalette[Math.floor(Math.random()*heartPalette.length)];
                else if (isTree) c = goldPalette[Math.floor(Math.random()*goldPalette.length)];
                else c = whitePalette[Math.floor(Math.random()*whitePalette.length)];
                
            } else {
                // Finale Reserve
                dest = 'RESERVE';
                c = (Math.random()>0.5) ? goldPalette[0] : whitePalette[0];
            }

            colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;

            // GALAXY
            const rIdx = Math.floor(Math.random() * RING_COUNT);
            const baseRadius = 5 + (rIdx * 1.5);
            const spread = (Math.random() - 0.5) * 2.0; 
            const finalRadius = baseRadius + spread;
            const angle = Math.random() * Math.PI * 2;

            galaxyTargets[i] = {
                type: 'RING',
                x: Math.cos(angle) * finalRadius,
                y: -10,
                z: Math.sin(angle) * finalRadius,
                angle: angle,
                radius: finalRadius,
                ringOffset: rIdx * 0.4
            };

            // TREE
            const h = Math.random(); 
            const treeY = h * 35 - 5; 
            const tr = (1 - h) * 14 * (0.5 + 0.5 * Math.random());
            const ta = Math.random() * Math.PI * 2;
            treeTargets[i] = {x: Math.cos(ta)*tr, y: treeY, z: Math.sin(ta)*tr, h: h};

            // HEART (Scale 0.2)
            if (dest === 'HEART') {
                const t = Math.random() * Math.PI * 2;
                const pt = getHeartOutline(t);
                const fillScale = Math.sqrt(Math.random()); 
                const scale = 0.2; 
                
                heartTargets[i] = {
                    x: pt.x * scale * fillScale, 
                    y: 33 + (pt.y * scale * fillScale), 
                    z: (Math.random()-0.5) * 6 * fillScale 
                };
            } else {
                heartTargets[i] = {x:0, y:0, z:0}; 
            }

            pos[i*3] = 0; pos[i*3+1] = -100; pos[i*3+2] = 0;
            sizes[i] = 0;
            data[i] = { vx:0, vy:0, vz:0, state:'IDLE', dest: dest };
        }

        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const mat = new THREE.PointsMaterial({
            size: 1.5, map: getTexture(), 
            vertexColors: true, blending: THREE.AdditiveBlending, 
            depthWrite: false, transparent: true
        });
        const system = new THREE.Points(geo, mat);
        scene.add(system);

        // --- SNOW SYSTEM ---
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(SNOW_COUNT * 3);
        const snowVel = [];
        for (let i = 0; i < SNOW_COUNT; i++) {
            snowPos[i*3] = (Math.random() - 0.5) * 250;
            snowPos[i*3+1] = Math.random() * 150 + 50;
            snowPos[i*3+2] = (Math.random() - 0.5) * 250;
            snowVel[i] = {
                vy: -(0.05 + Math.random() * 0.08),
                vx: (Math.random() - 0.5) * 0.03,
                vz: (Math.random() - 0.5) * 0.03
            };
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({
            size: 1.2, color: 0xffffff, map: getTexture(), 
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.7
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);


        const orbGeo = new THREE.BufferGeometry();
        const orbPos = new Float32Array(6);
        orbGeo.setAttribute('position', new THREE.BufferAttribute(orbPos, 3));
        const orbMat = new THREE.PointsMaterial({ size: 8, color: 0xffffff, map: getTexture(), blending: THREE.AdditiveBlending, depthWrite: false });
        const orbs = new THREE.Points(orbGeo, orbMat);
        scene.add(orbs);

        // --- TIMELINE ---
        let time = 0;
        
        const T_INTRO = 4.0;    
        const T_RING  = 7.0;    
        const T_TREE  = 9.0;    
        const T_HEART = 12.0;   
        const T_FINALE_START = 15.0;   
        const T_FINALE_END   = 19.0;  

        let nextFireworkTime = 0;
        let nextFinaleTime = 0;
        let finaleIterator = 0;

        function launchFirework() {
            let count = 0;
            const lx = (Math.random()-0.5)*50; const lz = (Math.random()-0.5)*50;
            const h = 25 + Math.random()*15;
            for(let i=0; i<PARTICLE_COUNT; i++) {
                if(data[i].state === 'IDLE' && count < 400) { 
                    data[i].state = 'ROCKET';
                    pos[i*3] = lx; pos[i*3+1] = -10; pos[i*3+2] = lz;
                    data[i].vx = (Math.random()-0.5)*0.25; 
                    data[i].vy = 0.7+Math.random()*0.4; 
                    data[i].vz = (Math.random()-0.5)*0.25;
                    data[i].targetH = h;
                    sizes[i] = 2.0;
                    count++;
                }
            }
        }

        function launchFinale() {
            let count = 0;
            const lx = (Math.random()-0.5)*70; const lz = (Math.random()-0.5)*70;
            const h = 30 + Math.random()*20;
            
            let attempts = 0;
            while(count < 200 && attempts < RESERVE_COUNT) {
                const i = STRUCTURE_COUNT + finaleIterator;
                const d = data[i];
                finaleIterator = (finaleIterator + 1) % RESERVE_COUNT;
                attempts++;

                if(d.state !== 'ROCKET' && d.state !== 'EXPLODE') {
                    d.state = 'ROCKET';
                    pos[i*3] = lx; pos[i*3+1] = -10; pos[i*3+2] = lz;
                    data[i].vx = (Math.random()-0.5)*0.35; 
                    data[i].vy = 0.8+Math.random()*0.5; 
                    data[i].vz = (Math.random()-0.5)*0.35;
                    data[i].targetH = h;
                    sizes[i] = 2.5;
                    count++;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            time += 0.016;

            // 1. INTRO
            if(time < T_INTRO && time > nextFireworkTime) {
                launchFirework(); nextFireworkTime = time + 0.25; 
            }

            // 2. SHORT FINALE
            if(time > T_FINALE_START && time < T_FINALE_END && time > nextFinaleTime) {
                launchFinale(); nextFinaleTime = time + 0.15; 
            }

            // 3. SNOW ANIMATION
            for(let i=0; i<SNOW_COUNT; i++) {
                let sy = snowPos[i*3+1];
                const v = snowVel[i];
                sy += v.vy;
                snowPos[i*3] += v.vx + Math.sin(time + i*0.1)*0.01;
                snowPos[i*3+2] += v.vz + Math.cos(time + i*0.1)*0.01;
                
                if (sy < -12) {
                    sy = 150; 
                    snowPos[i*3] = (Math.random() - 0.5) * 250;
                    snowPos[i*3+2] = (Math.random() - 0.5) * 250;
                }
                snowPos[i*3+1] = sy;
            }
            snowGeo.attributes.position.needsUpdate = true;


            // 4. MAIN SYSTEM ANIMATION
            for(let i=0; i<PARTICLE_COUNT; i++) {
                const d = data[i];
                let x=pos[i*3], y=pos[i*3+1], z=pos[i*3+2];

                if(time > T_INTRO && time < T_FINALE_START && d.state === 'IDLE') {
                    d.state = 'GALAXY';
                    const gt = galaxyTargets[i];
                    x = gt.x; y = -10; z = gt.z;
                    sizes[i] = 1.2;
                }

                if(d.state === 'ROCKET') {
                    x+=d.vx; y+=d.vy; z+=d.vz; d.vy*=0.98;
                    if(d.vy < 0.1) { 
                        d.state='EXPLODE'; 
                        const s=0.3+Math.random()*0.6; const a=Math.random()*6.28; const b=Math.random()*3.14;
                        d.vx=Math.sin(b)*Math.cos(a)*s; d.vy=Math.cos(b)*s; d.vz=Math.sin(b)*Math.sin(a)*s;
                        sizes[i]=3.0; 
                    }
                }
                else if(d.state === 'EXPLODE') {
                    x+=d.vx; y+=d.vy; z+=d.vz; d.vy-=0.015; d.vx*=0.95; d.vy*=0.95; d.vz*=0.95;
                    
                    if(time > T_FINALE_START) {
                        if(y < -20) { d.state='IDLE'; sizes[i]=0; y=-100;}
                    } else {
                        if(time > T_INTRO) d.state='GALAXY';
                        if(y < -20) { d.state='IDLE'; sizes[i]=0; y=-100; }
                    }
                }
                else if(d.state === 'GALAXY') {
                    const gt = galaxyTargets[i];
                    const spin = time * 0.2; 
                    const tx = Math.cos(gt.angle + spin) * gt.radius;
                    const tz = Math.sin(gt.angle + spin) * gt.radius;
                    const wave = Math.sin(time * 1.0 - gt.ringOffset) * 0.4; 
                    const ty = -10 + wave;
                    
                    x += (tx - x) * 0.1; y += (ty - y) * 0.1; z += (tz - z) * 0.1;
                    sizes[i] = 1.5;

                    if(time > T_TREE && d.dest === 'TREE') d.state = 'TREE';
                    if(time > T_HEART && d.dest === 'HEART') d.state = 'HEART';
                }
                else if(d.state === 'TREE') {
                    const tt = treeTargets[i];
                    const prog = (time - T_TREE)/(T_HEART - T_TREE);
                    const beamH = prog*45 - 5;
                    
                    if(tt.h*35 - 5 < beamH) {
                        const rot = time*0.8; 
                        x += (tt.x*Math.cos(rot) - tt.z*Math.sin(rot) - x)*0.12; 
                        y += (tt.y - y)*0.12;
                        z += (tt.x*Math.sin(rot) + tt.z*Math.cos(rot) - z)*0.12;
                    } else {
                        const gt = galaxyTargets[i];
                        const wave = Math.sin(time * 1.0 - gt.ringOffset) * 0.4; 
                        x += (Math.cos(gt.angle+time*0.2)*gt.radius - x)*0.08;
                        y += ((-10+wave) - y)*0.08;
                        z += (Math.sin(gt.angle+time*0.2)*gt.radius - z)*0.08;
                    }
                }
                else if(d.state === 'HEART') {
                    const ht = heartTargets[i];
                    const rot = time * 0.8;
                    const fx = ht.x * Math.cos(rot) - ht.z * Math.sin(rot);
                    const fz = ht.x * Math.sin(rot) + ht.z * Math.cos(rot);
                    
                    x += (fx - x) * 0.12;
                    y += (ht.y - y) * 0.12;
                    z += (fz - z) * 0.12;
                    sizes[i] = 5.0;
                }

                pos[i*3]=x; pos[i*3+1]=y; pos[i*3+2]=z;
            }
            geo.attributes.position.needsUpdate=true;
            geo.attributes.size.needsUpdate=true;

            if(time > T_TREE && time < T_HEART) {
                orbs.visible = true;
                const prog = (time-T_TREE)/(T_HEART-T_TREE);
                const h = prog*45 - 5; const r = (1-prog)*15 + 1; const s = time*10;
                orbPos[0]=Math.cos(s)*r; orbPos[1]=h; orbPos[2]=Math.sin(s)*r;
                orbPos[3]=Math.cos(s+3.14)*r; orbPos[4]=h; orbPos[5]=Math.sin(s+3.14)*r;
                orbGeo.attributes.position.needsUpdate=true;
            } else orbs.visible=false;

            if(time > T_TREE) document.getElementById('text').style.opacity = 1;
            
            camera.position.x = Math.sin(time*0.1)*CAM_DIST;
            camera.position.z = Math.cos(time*0.1)*CAM_DIST;
            camera.lookAt(0, 15, 0); 
            
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
    </script>
</body>
</html>